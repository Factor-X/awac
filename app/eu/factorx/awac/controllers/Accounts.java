/*
 *
 * Instant Play Framework
 * AWAC
 *                       
 *
 * Copyright (c) 2014 Factor-X.
 * Author Gaston Hollands
 *
 */

package eu.factorx.awac.controllers;

import static play.data.Form.form;


//for XML
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import play.data.Form;
// for JSON
import play.libs.Json;
import play.mvc.Controller;
import play.mvc.Result;
import play.mvc.Security;
import eu.factorx.awac.common.AccountStatusType;
import eu.factorx.awac.models.Account;
// for PDF
import eu.factorx.awac.util.pdf.PDF;
import eu.factorx.awac.views.html.account.*;

/**
 * Manage a database of accounts
 */

@Security.Authenticated(Secured.class)
public class Accounts extends Controller {

    /**
     * This result directly redirect to application home is user of type Account.
     * or redirects to the list of accounts if admin
     */
    public static Result GO_HOME = redirect(
            eu.factorx.awac.controllers.routes.Accounts.list(0, "identifier", "asc", "")
            /*
    			(eu.factorx.awac.controllers.Secured.isAdministrator()==true)?
    			(eu.factorx.awac.controllers.routes.Accounts.list(0, "identifier", "asc", "")):
    			(eu.factorx.awac.controllers.Application.index())
    		 */
    );

    public static Result GO_MAIN = redirect(
            eu.factorx.awac.controllers.routes.Application.index()
    );

    /**
     * Handle default path requests, redirect to account list
     */
    public static Result index() {
        return GO_HOME;
    }

    /**
     * Display the paginated list of accounts.
     *
     * @param page   Current page number (starts from 0)
     * @param sortBy Column to be sorted
     * @param order  Sort order (either asc or desc)
     * @param filter Filter applied on accounts names
     */
    public static Result list(int page, String sortBy, String order, String filter) {
        return ok(
                list.render(
                        Account.page(page, 10, sortBy, order, filter),
                        sortBy, order, filter
                )
        );
    }

    /**
     * Display list of accounts.
     * for PDF output
     */
    public static Result asPdf() {
        return PDF.ok(document.render(Account.find.all()));
    }

    /**
     * Display list of accounts.
     * for JSON output
     */
    public static Result asJson() {
        return ok(Json.toJson(Account.find.all()));
        //return TODO;
    }

    /**
     * Display list of accounts.
     * for XML output
     */
    public static Result asXml() {
        try {
            JAXBContext context = JAXBContext.newInstance(Account.class);
            Marshaller marshaller = context.createMarshaller();

            // Use linefeeds and indentation in the outputted XML
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
            marshaller.marshal(Account.find.byId(new Long(21)), System.out);
        } catch (JAXBException jaxbe) {
            play.Logger.debug("JAXB Exception : " + jaxbe);
            return (GO_HOME);
        }

        return ok(Json.toJson(Account.find.all()));
        //return TODO;
    }


    /**
     * Display the 'edit form' of a existing Administrator.
     *
     * @param id Id of the account to edit
     */
    public static Result edit(Long id) {
        if (Secured.isAccount() || Secured.isAdministrator()) {
            Form<Account> accountForm = form(Account.class).fill(
                    Account.find.byId(id)
            );
            return ok(
                    editForm.render(id, accountForm)
            );
        } else {
            return forbidden();
        }
    }

    /**
     * Handle the 'edit form' submission
     *
     * @param id Id of the account to edit
     */
    public static Result update(Long id) {
        if (Secured.isAccount() || Secured.isAdministrator()) {
            Form<Account> accountForm = form(Account.class).bindFromRequest();

            if (accountForm.hasErrors()) {
                return badRequest(editForm.render(id, accountForm));
            }

            //Automatic binding does not work for embedded objects.
            //accountForm.get().update(id);

            // use manuel settings
            // Automatic binding does not work for embedded objects.
            // use manuel binding.
            Account acc = accountForm.get();

            // basicaly getter and setter are generated by Play
            // This gives a strange way to affect/assign data on the code
            // But play uses internally getters and setter to keep encapsulation
            play.Logger.debug("Person ID:" + acc.personId);
            play.Logger.debug("LastName:" + acc.lastname);
            play.Logger.debug("FirstName:" + acc.firstname);
            play.Logger.debug("Identifier:" + acc.identifier);
            play.Logger.debug("Password:" + acc.password);
            play.Logger.debug("Age:" + acc.age);
            play.Logger.debug("Status:" + acc.accountStatus);
            play.Logger.debug("Street:" + acc.address.street);
            play.Logger.debug("PostalCode:" + acc.address.postalcode);
            play.Logger.debug("City:" + acc.address.city);
            play.Logger.debug("Country:" + acc.address.country);
            play.Logger.debug("VAT number:" + acc.vat.vatNumber);
            play.Logger.debug("VIES verified:" + acc.vat.viesVerified);
            play.Logger.debug("VIES name:" + acc.vat.viesName);
            play.Logger.debug("VIES address:" + acc.vat.viesAddress);
            play.Logger.debug("VIES request date:" + acc.vat.viesRequestDate);
            play.Logger.debug("VIES request ID:" + acc.vat.viesRequestId);

            eu.factorx.awac.models.Account updateAccount = eu.factorx.awac.models.Account.find.byId(id);
            updateAccount.identifier = acc.identifier;
            updateAccount.password = acc.password;
            updateAccount.firstname = acc.firstname;
            updateAccount.lastname = acc.lastname;
            updateAccount.email = acc.email;
            updateAccount.age = acc.age;
            updateAccount.accountStatus = acc.accountStatus;

            updateAccount.address.street = acc.address.street;
            updateAccount.address.postalcode = acc.address.postalcode;
            updateAccount.address.city = acc.address.city;
            updateAccount.address.country = acc.address.country;

            updateAccount.vat.vatNumber = acc.vat.vatNumber;
            updateAccount.vat.viesVerified = acc.vat.viesVerified;
            updateAccount.vat.viesAddress = acc.vat.viesAddress;
            updateAccount.vat.viesName = acc.vat.viesName;
            updateAccount.vat.viesRequestDate = acc.vat.viesRequestDate;
            updateAccount.vat.viesRequestId = acc.vat.viesRequestId;

            updateAccount.update();

            flash("success", "Account " + accountForm.get().identifier + " has been updated");

            if (eu.factorx.awac.controllers.Secured.isAccount()) {
                return GO_MAIN;
            } else {
                return GO_HOME;
            }
        } else {
            return forbidden();
        }
    }

    /**
     * Display the 'new account form'.
     */
    public static Result create() {
        Form<Account> accountForm = form(Account.class);
        return ok(
                createForm.render(accountForm)
        );
    }

    /**
     * Handle the 'new account form' submission
     */
    public static Result save() {
        Form<Account> accountForm = form(Account.class).bindFromRequest();
        if (accountForm.hasErrors()) {
            return badRequest(createForm.render(accountForm));
        }
        accountForm.get().save();
        flash("success", "Account " + accountForm.get().identifier + " has been created");

        if (eu.factorx.awac.controllers.Secured.isAccount()) {
            return GO_MAIN;
        } else {
            return GO_HOME;
        }
    }

    /**
     * Handle account deletion
     */
    public static Result delete(Long id) {
        Account.find.ref(id).delete();
        flash("success", "Account has been deleted");

        if (eu.factorx.awac.controllers.Secured.isAccount()) {
            return GO_MAIN;
        } else {
            return GO_HOME;
        }
    }
}